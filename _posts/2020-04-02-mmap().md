---
title: mmap()原理与应用
date: 2020-04-01 23:58:53 
category: 
- 计算机原理
tags: 
- CSAPP 
- memory
- operating system
---

# 什么是 mmap()
Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为*内存映射*。mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，且进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write()等操作。

![Gt0kNT.png](https://s1.ax1x.com/2020/04/02/Gt0kNT.png)

注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。  

---
# 为什么使用 mmap()

Linux通过内存映像机制来提供用户程序对内存直接访问的能力。内存映像的意思是把内核中特定部分的内存空间映射到用户级程序的内存空间去。也就是说，**用户空间和内核空间共享一块相同的内存**。这样做的直观效果显而易见：内核在这块地址内存储变更的任何数据，用户可以立即发现和使用，根本无须数据拷贝。举个例子理解一下，使用mmap方式获取磁盘上的文件信息，只需要将磁盘上的数据拷贝至那块共享内存中去，用户进程可以直接获取到信息，而相对于传统的write/read　IO系统调用, 必须先把数据从磁盘拷贝至到**内核缓冲区中(页缓冲)**，然后再把数据拷贝至用户进程中。两者相比，**mmap会少一次拷贝数据**，这样带来的性能提升是巨大的。

使用内存访问来取代read()和write()系统调用能够简化一些应用程序的逻辑。在一些情况下，它能够比使用传统的I/O系统调用执行文件I/O这种做法提供更好的性能。
原因是：

- 正常的read()或write()需要两次传输：一次是在文件和内核高速缓冲区之间，另一次是在高速缓冲区和用户空间缓冲区之间。使用mmap()就不需要第二次传输了。对于输入来讲，一旦内核将相应的文件块映射进内存之后，用户进程就能够使用这些数据了；对于输出来讲，用户进程仅仅需要修改内核中的内容，然后可以依靠内核内存管理器来自动更新底层的文件。
![GtBowt.png](https://s1.ax1x.com/2020/04/02/GtBowt.png)
- 除了节省内核空间和用户空间之间的一次传输之外，mmap()还能够通过减少所需使用的内存来提升性能。当使用read()或write()时，数据将被保存在两个缓冲区中：一个位于用户空间，另个一位于内核空间。当使用mmap()时，内核空间和用户空间会共享同一个缓冲区。此外，如果多个进程正在同一个文件（共享对象）上执行I/O，那么它们通过使用mmap()就能够共享同一个内核缓冲区，从而又能够节省内存的消耗。

---
# 如何使用mmap()
mmap()函数原型如下，
```C
 #include <sys/mman.h>

 void *mmap (void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

### Arguments Describes (参数描述)

- 参数addr指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。
- len是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开始算起。
- prot 参数指定共享内存的访问权限。可取如下几个值的或：PROT_READ（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）, PROT_NONE（不可访问）。
- flags由以下几个常值指定：MAP_SHARED , MAP_PRIVATE , MAP_FIXED，其中，MAP_SHARED , MAP_PRIVATE必选其一，而MAP_FIXED则不推荐使用。offset参数一般设为0，表示从文件头开始映射。
- 参数fd为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANON，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信）。
- offset参数一般设为0，表示从文件头开始映射, 代表偏移量。
  
### Return Value (返回值)

函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。

## 两种映射方式

### 1. 基于文件的映射

将虚拟内存一个*区域*（Area,即Linux下已分配的虚拟内存的连续片(chunk))映射到一个普通磁盘文件的连续部分，如一个可执行文件。由于*按需页面调度*，这些虚拟页面没有实际交换入物理内存，知道CPU第一次引用到这个页面。
适用于任何进程之间, 此时，需要打开或创建一个文件，然后再调用mmap(), 典型调用代码如下：

```C
fd = open(name, flag, mode);
if(fd<0) //open()出错将返回-1
{
	printf("error!\n");
}
        
/* 这块内存可读可写可执行 */
ptr = mmap(NULL, len , PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED , fd , 0); 
```

这样用户进程就可以像读取内存一样读取文件了,效率非常高。

### 2. 匿名映射

匿名映射是将一个区域映射到一个匿名文件，该匿名文件由内核创建。
一个匿名映射没有对应的文件，这种映射的分页会被初始化为0（请求二进制零）。CPU第一次引用这个区域的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，将其换出来（用二进制零覆盖）并更新页表，并将此页面标记为驻留在内存中的。  

---
# mmap 具体原理

## 1.进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域

- 进程在用户空间调用库函数mmap，原型：`void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)`;

- 在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

- 为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化

- 将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中
  
## 2.调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系

映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的*文件结构体*（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。

通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：`int mmap(struct file *filp, struct vm_area_struct *vma)`，不同于用户空间库函数。

内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。

通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

## 3.进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝

注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。(按需页面调度)

- 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常，控制转移至异常处理程序。

- 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。

- 调页过程先在*交换缓存空间*（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

- 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程（有点像写时复制技术）。

注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。


---
本文改编自[彻底理解mmap()](https://blog.csdn.net/Holy_666/article/details/86532671), 原文遵循 CC 4.0 BY-SA 版权协议
